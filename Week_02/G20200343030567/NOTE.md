学习笔记

## 笔记

复杂的问题都会归结为找重复性

1、优化的思想
升维
空间换时间
2、解题最大误区
只做一遍
3、懵逼的时候：
3.1 能不能暴力
3.2 基本情况罗列 递推，数学归纳法
3.3 找最近重复子问题
代码本质就三部分
if else switch
while loop
递归
4、什么时候可以用栈来解决
最近相关性，最外层是一对、最内层是一对，类似洋葱的结构
先来后到
5、四件套
沟通清楚题目
列举所有可能性
编码
测试代码
6、数和图的最大差别就是有没有环
链表是特殊化的树、树是特殊化的图
7、二叉搜索树
查询到的位置，就是需要插入的位置
8、递归结构模板
8.1 递归终结条件 recursion terminator
8.2 处理当前层逻辑 process logic in current level
8.3 下探到下一层 drill down
8.4 清理当前层 reverse the current level status if needed
9、递归要点
9.1 不要人肉进行递归（最大误区）
9.2 找最近重复子问题
9.3 数学归纳法
mutual exclusive, complete exhaustive


## 散列表

散列表：
1、散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表。
参赛编号转化为数组下标的映射方法就叫作散列函数（或“Hash 函数”“哈希函数”），而散列函数计算得到的值就叫作散列值（或“Hash 值”“哈希值”）
2、三点散列函数设计的基本要求：
2.1 散列函数计算得到的散列值是一个非负整数；
2.2 如果 key1 = key2，那 hash(key1) == hash(key2)；
2.3 如果 key1 ≠ key2，那 hash(key1) ≠ hash(key2)。
3、哈希算法
MD5、SHA、CRC
4、散列冲突
开放寻址法（open addressing）和链表法（chaining）
5、开放寻址法
核心思想是，如果出现了散列冲突，我们就重新探测一个空闲位置，将其插入
线性探测（Linear Probing）二次探测（Quadratic probing）和双重散列（Double hashing）
散列表的装载因子=填入表中的元素个数/散列表的长度
装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。
6、链表法
每个“桶（bucket）”或者“槽（slot）”会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中
7、Word 文档中单词拼写检查功能是如何实现的？
常用的英文单词有 20 万个左右，假设单词的平均长度是 10 个字母，平均一个单词占用 10 个字节的内存空间，那 20 万英文单词大约占 2MB 的存储空间，就算放大 10 倍也就是 20MB。对于现在的计算机来说，这个大小完全可以放在内存里面。所以我们可以用散列表来存储整个英文单词词典。
当用户输入某个英文单词时，我们拿用户输入的单词去散列表中查找。如果查到，则说明拼写正确；如果没有查到，则说明拼写可能有误，给予提示。借助散列表这种数据结构，我们就可以轻松实现快速判断是否存在拼写错误。


