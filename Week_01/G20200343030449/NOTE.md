学习笔记

066 加一：
因为数字的排列是从高位到低位，要处理的时候要从vector的最后开始处理，有点奇怪。
所以一开始用了两个Stack来实现。
第一步将数字压栈，这样得到的栈里的数字就是从低位到高位的，然后循环处理栈里的元素。
第二步将处理好的数字压栈，这样得到的数字又是从高位到低位的，最后循环把栈里的元素push back到vector里。

时间复杂度o(n) 空间复杂度o(n),使用了两个额外的元素。

LeetCode的解答是在原数组上进行+1，当发现不需要再进行进位的时候直接返回，否则继续一直到最后如果没有返回说明还需要进一位。
这时候有个技巧是在最后一位补0后在第一位补1。

在原vector基础上操作的问题是最后补1的时候需要移动整个数组，即使这样空间复杂度应该比我的也要更好一些。
我上传了自己的实现方法，在下一次刷题的时候会使用like最多的方法。

641 设计循环双端队列：
我用了循环列表的方式实现的双端队列：
优点：插入，删除，查询第一个和最后一个的操作都可以在o(1)时间内完成。
缺点：链表的代码比较复杂，需要经常申请与回收内存空间。需要额外的变量来存储当前使用的大小与最大容量。没有把最大容量的概念给用上去。

力扣推荐方法：动态数组。
使用固定大小的数组，使用first和rear两个指针来控制元素的插入删除，当first+1=last的时候说明容量已经耗尽。
优点：代码实现更简单，不需要额外的参数来保存已经使用的大小和容量。
缺点：需要额外的1个数组元素来判断容量是否满。


42 接雨水：
接雨水能想到的最简单的方法就是按列来处理，每次都找左边和右边最小的列，比较容易想到的方法就是用一个数组来保存最小高度的状态，比较容易理解的是当我们从左向右遍历的时候，我们可以在这个基础上更新左边的最小高度，而右边的最小高度依然需要一个数组来保存，虽然后续有将右边的最小高度以一个变量取代已经用栈的方式来实现，这两种方式还没有完全理解的情况下，第三种解法是目前自己掌握的最熟练的。
后续五毒再刷这道题目的时候，会深入理解第四种解法和栈的方式实现的解法。
