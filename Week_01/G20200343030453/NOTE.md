学习笔记

学号：G20200343030453   姓名: 马辉明

日期： 2020.2.16

[21] 合并两个有序链表 题目总结
（1）迭代法：
归并排序的思想，因为两个链表有序，只做一次排序即可，稍作改进，当其中一个有序表结束时，可以将 next 指向另一个链表的剩余节点，不需要遍历完之后作判断，这样节省了比较时间，时间复杂度 O（n + m）
（2）递归法：终止条件：当 l1 或 l2 为空时，返回剩余 l2 或 l1 结束；
返回值为每一层都已排好序的头指针；
递归内容：当 l1 的值 val 较小时，l1 的 next 指向之后排完序的链表头，否则，l2 的 next 指向排好序的链表头；
时间复杂度：O（n + m）空间复杂度也是一样，递归会消耗（n + m）个栈空间

[42] 接雨水  题目总结
（1） 暴力法  遍历每一根柱子，找出该柱子左右两边最高的柱子取较小值，较小值与当前柱子差值为接雨水数
此题有很多解法，后续抽空总结...

[641] 设计循环双端队列 题目总结 https://blog.csdn.net/xiaoma_2018/article/details/103997820
实现该循环队列，需要注意以下几点：

1.判断队列为空？ 当收尾指针相等，队列为空，head == tail
2.判断队列已满？ 当尾指针的下一位等于头指针，队列已满，(tail + 1 + capacity) % capacity == head;
3.初始化队列时？ 首尾指针从0开始， head = tail = 0
4.从头部插入数据？ head 指针向前移动， head = (head - 1 + capacity) % capacity
5.从尾部插入数据？ tail 指针向后移动， tail = (tail + 1) % capacity
6.从头部删除数据？ head 指针向后移动， head = (head + 1) % capacity
7.从尾部删除数据？ tail 指针向前移动， tail = (tail - 1 + capacity) % capacity
8.从尾部读取数据？ 考虑头部插入（head 前移一位）和尾部插入（插入后，tail后移一位），所以读取data[(tail - 1 + capacity) % capacity]

[26] 删除排序数组中的重复项 题目总结

用双指针遍历


