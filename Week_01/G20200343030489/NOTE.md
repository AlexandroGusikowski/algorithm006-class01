学习笔记

### 删除排序数组中的重复项

刚开始拿到这个题的时候我的第一反应便是用另一个数组来存放数字，但是犯了一个致命错误，就是没有仔细审题。题目说道要在原地修改数组，所以我改变了思路。题目说道不需要考虑超出新长度后面的元素，也就是说在输出的时候我只要输出前面部分的数字即可，所以想到通过循环，与前面数字对比，若不相同，则把前面重复数字替换掉，例如112这情况，在第三个位置发现与第一个位置数字不同的时候，替换第二个位置的数字，使成为122，输出的时候只要将前面两个位置输出即可。

### 旋转数组

看到题目上说了要求使用空间复杂度为O(1)算法，但第一次还是尝试了通过存放到另一个数组来先将排序排好，再将临时的数组依次存回原来原来数组中。

但毕竟这方法的空间复杂度高了，不符合题意。所以用第二个方法，就是一位一位移动。先将最后一个数字临时存起，再将整个表右移动一位，最后把临时存的数字放置第一位，以此循环k次，实现旋转。但这个方法的时间复杂度高，为O(k*n)。

最后看了别人的题解，学会了用reverse这个函数，即反转。这个方法是基于这样的事实：当旋转数组k次的时候，k%n个尾部元素就会被移到头部，剩下向后移动。这个方法首先将所有元素反转，接着反转前k个元素，最后反转n-k个元素，就能得到相应的结果。此方法时间复杂度为O(n)。

### 合并两个有序链表

由于在链表上面还不太熟悉，所以直接看了别人的题解。在这题上，运用了迭代的方法。创建一个存储元素的链表，设置一个哨兵点，这样可以在后面容易返回合并后的链表。对比两个链表中的元素大小，存储在创建的链表中，排序后输出哨兵点后的元素，得到最终结果。

### 合并两个有序数组

由于题目中说明了第一个数组有足够空间存放第二个数组的元素，所以我在这先将第一个数组后面无关的数字进行替换，替换成第二组的数字，接着通过sort函数，直接对替换后的第一个数组排序，得到最终结果。

### 两数之和

看到题目后第一反应便是通过暴力方法，逐一排查，如果有相等情况，记录下相应位置。但是暴力法导致的就是时间复杂度高，为n^2^

所以看了别人的方法，运用哈希表。通过空间换时间的方式，可以将时间复杂度降到O(1)。在进行迭代并把元素放到列表中的同时，，还会回头来检查表是否已经存在当前元素对应的目标元素。

### 移动零

此题其实方法也简单，只需要在遍历过程中记录下数为0的个数，再进行数组中位置交换，将0移动到后方。

### 加一

第一次拿到这题就理解错误了，我将它理解为只需要改变最后一个数字即可，但此题的意思是这个数组就是整个数字，加上一就相当于总数加一得到新的总数。所以要考虑到9+1进一位的情况。这题可能会出现9999这样的所有位数上都为9的情况。所以需要从数组最后一位进行遍历，如果无9，直接加一并返回数组即可，若出现上面说的情况，则数组上所有的数都换为0。遍历结束后，将数组增加一位，并放上0，将数组第一个数字换为1即可得到答案。

